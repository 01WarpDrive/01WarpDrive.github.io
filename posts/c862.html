

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme="auto">



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" href="/img/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="舣星">
  <meta name="keywords" content>
  
    <meta name="description" content="记录笔者根据网上推荐的 leetcode 刷题指南的学习过程，以此文章勉励自己在代码上不断进步。">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode 刷题记录">
<meta property="og:url" content="https://01warpdrive.github.io/posts/c862.html">
<meta property="og:site_name" content="舣星码头">
<meta property="og:description" content="记录笔者根据网上推荐的 leetcode 刷题指南的学习过程，以此文章勉励自己在代码上不断进步。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://01warpdrive.github.io/img/index_img/leetcode.png">
<meta property="article:published_time" content="2023-08-18T03:11:38.000Z">
<meta property="article:modified_time" content="2023-09-25T08:14:01.746Z">
<meta property="article:author" content="舣星">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法，不定期更新">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://01warpdrive.github.io/img/index_img/leetcode.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>leetcode 刷题记录 - 舣星码头</title>

  <link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css">



  <link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css">

  <link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link rel="stylesheet" href="/css/main.css">


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css">
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css">
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"01warpdrive.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="舣星码头" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>舣星码头</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax="true" style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="leetcode 刷题记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-18 11:11" pubdate>
          2023年8月18日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">leetcode 刷题记录</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年9月25日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="leetcode-刷题记录"><a href="#leetcode-刷题记录" class="headerlink" title="leetcode 刷题记录"></a>leetcode 刷题记录</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li><p>刷题顺序参考<a target="_blank" rel="external nofollow noopener noreferrer" href="https://books.halfrost.com/leetcode/">序 | LeetCode Cookbook (halfrost.com)</a></p>
</li>
<li><p>所有思路分析中的公式、操作都是按照 C++ 语法表示的。</p>
</li>
<li><p>「分析」部分大多是参考了官方题解后自己整理的，想借此锻炼自己的表达能力。</p>
</li>
<li><p><strong>本文章更多是记录个人的刷题情况，其中的题解分析往往是事先参考了官网相关题解，语言表述和技术细节多有不如，不推荐作为您的主要刷题参考。</strong></p>
</li>
</ul>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4 寻找两个正序数组的中位数"></a>4 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h2><blockquote>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数 。算法的时间复杂度应该为 O(log (m+n)) 。
链接：https://leetcode.cn/problems/median-of-two-sorted-arrays</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>要求对数时间复杂度，联想到二分查找。二分查找在有序数组中查找指定的数，每次迭代中可以通过大小比较排除一半的数据。本题要在两个数组中找中位数，是否可以通过选定 pivots ，在一次迭代中排除掉一定比例的数据？</p>
<p>我们注意到，中位数问题是第 k 小问题的一个特例：</p>
<ul>
<li>一个偶数数组的中位数为它第$len/2$小的元素和$len/2 + 1$的元素的均值</li>
<li>一个奇数数组的中位数为它第$len/2 + 1$ 的元素</li>
</ul>
<p>显然，第一次迭代并排除部分数据后，我们的问题就变成了找第 $k$ 小的数。因此，pivots 的选取和 $k$ 有关。</p>
<ul>
<li>取<code>pivot1 = nums1[k/2-1]</code> 和 <code>pivot2 = nums2[k/2-1] </code>进行比较</li>
<li>取 <code>pivot = min(pivot1, pivot2)</code>，两个数组中小于等于 pivot 的元素共计不会超过 $(k/2-1) + (k/2-1) &lt;= k-2$ 个</li>
<li>pivot 所在数组的 pivot 前部分元素可以排除掉</li>
<li>修改两个数组（通过更改起始下标），修改 k，重复以上步骤，直到 k=1</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums1.<span class="hljs-built_in">size</span>() + nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthNum</span>(nums1, nums2, len / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (<span class="hljs-built_in">findKthNum</span>(nums1, nums2, len / <span class="hljs-number">2</span>) + <span class="hljs-built_in">findKthNum</span>(nums1, nums2, len / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findKthNum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index1, index2, pivot1, pivot2;<br>        <span class="hljs-type">int</span> left1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left1 == m) <span class="hljs-keyword">return</span> nums2[left2 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (left2 == n) <span class="hljs-keyword">return</span> nums1[left1 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(nums1[left1], nums2[left2]);<br>            index1 = std::<span class="hljs-built_in">min</span>(left1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>            index2 = std::<span class="hljs-built_in">min</span>(left2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;<br>                k -= index1 - left1 + <span class="hljs-number">1</span>;<br>                left1 = index1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                k -= index2 - left2 + <span class="hljs-number">1</span>;<br>                left2 = index2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>写 while 循环先确定退出条件</li>
<li>数组选取 pivot 时确保不会越界</li>
<li>将要用的数据先确定类型，如 <code>int m = nums1.size()</code>，在 leetcode 中，<code>min(left1 + k / 2 - 1, nums1.size() - 1)</code> 会由于<code>nums1.size()</code> 类型不是 <code>int</code> 的原因而无法调用</li>
</ul>
<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/container-with-most-water/">盛最多水的容器</a></h2><p>难度中等</p>
<p>4360</p>
<blockquote>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。
链接：https://leetcode.cn/problems/container-with-most-water</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>数组类型的数据结构，首先想到的便是遍历。其中，双指针遍历（滑动窗口）是很常见的思路。笔者认为滑动窗口的思考方法，优先考虑从大窗口变成小窗口。</p>
<p>本题中，笔者用两个指针$i$,$j$表示窗口边界。当向中间移动两个指针时，宽度减小。要想获得更大的容量，就得找到更大的高度。由于高度取决于两个指针中的“短板”， 因此，只有当内移短板指针时，才需要判断并更新当前的最大容量。</p>
<h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>将所有双指针组合视作$C(n,2)$个状态，则每次更新容量，都会剔除部分「不大于」当前最大容量的状态。因此，当最终只剩下一个状态时，必定不小于所有已经剔除的状态。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, capacity = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            capacity = height[i] &lt; height[j] ?<br>                        <span class="hljs-built_in">max</span>(capacity, (j - i) * height[i++]): <span class="hljs-comment">// 注意 j-i 在 i++ 前</span><br>                        <span class="hljs-built_in">max</span>(capacity, (j - i) * height[j--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> capacity;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h3><ul>
<li>一种思路：遍历——双指针遍历（滑动窗口）</li>
<li>本次的代码看起来有点炫技。笔者认为将代码写得通俗易懂和佶屈聱牙是两种不同的境界，前者适合一个优秀理想的开发团队，后者则是身处不稳定的职位时提高自身不可替代性的一种手段。实际上本次的代码只是个小细节，真正的佶屈聱牙应当是优秀特异的算法思路和先进高效的代码技术。</li>
</ul>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>暴力遍历需要$O(n^3)$，因为涉及到大小比较，考虑对数组排序。</p>
<p>由于返回的三元组不允许重复，因此分析时可以把重复元素排除。假定$i&lt;j&lt;k$，第一层遍历选定数字 $num[i]$ ，则问题转变为在有序数组中寻找两数之和。显然，对于 $i$ 后面的子数组，通过维持两个指针 $j,k$ ，不断右移、左移两个指针即可在 $O(n)$ 时间内找到所有合适的 $j,k$。</p>
<p>过程中需要添加判断语句排除重复元素。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = &#123;&#125;;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k =  nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    j++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                tmp = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">0</span>) &#123;<br>                    k--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j++], nums[k--]&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    j++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h3><ul>
<li>涉及元素比较的数组题，可以考虑先排序数组</li>
</ul>
<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/3sum-closest/">16. 最接近的三数之和</a></h2><blockquote>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>本题是「15. 三数之和」的变种。在三数之和中，需要列举和为0的三元组，算法需要将三元组的和与0对比。套用到本题上，则是将三元组的和与 target 对比。</p>
<p>依旧通过在升序数组上的双指针实现。从「11. 盛最多水的容器」开始的三题就是不断应用这种滑动窗口的思路，其本质在本题的官方题解中给出了很精炼的阐述：</p>
<blockquote>
<p>每一次枚举的过程中，我们尝试边界上的两个元素，根据它们与 target 的值的关系，选择「抛弃」左边界的元素还是右边界的元素，从而减少了枚举的范围。
链接：https://leetcode.cn/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/</p>
</blockquote>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans;<br>        <span class="hljs-type">int</span> dist = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k =  nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    j++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                tmp = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (tmp &gt; target) &#123;<br>                    <span class="hljs-keyword">if</span> (tmp - target &lt; dist) &#123;<br>                        dist = tmp - target;<br>                        ans = tmp;<br>                    &#125;<br>                    k--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp == target) &#123;<br>                    <span class="hljs-keyword">return</span> target;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (target - tmp &lt; dist) &#123;<br>                        dist = target - tmp;<br>                        ans = tmp;<br>                    &#125;<br>                    j++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li>0 &lt;= a, b, c, d &lt; n</li>
<li>a、b、c 和 d 互不相同</li>
<li>nums[a] + nums[b] + nums[c] + nums[d] == target</li>
</ul>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>转换为三数之和做。理论上可以通过排除一些特殊情况来减少遍历。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> st) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = st; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; st &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k =  nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &lt; k) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    j++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>                    k--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[st<span class="hljs-number">-1</span>], nums[i], nums[j++], nums[k--]&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    j++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = &#123;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; tmp = &#123;&#125;;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            tmp = <span class="hljs-built_in">threeSum</span>(nums, target - nums[i], i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : tmp) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(k);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-3"><a href="#心得-3" class="headerlink" title="心得"></a>心得</h3><ul>
<li><p>本题中出现了一些超出 int 的输入。一般 int 的范围视作 $-2147483648 ~ 2147483647$。从应试的角度，当出现$10^9$时，在进行运算时要注意换用 <code>long long</code>。</p>
</li>
<li><p>原先在处理数据结构时，总是习惯像这样 <code>long sum = nums[i] + nums[j] + nums[k];</code>，只注意等号左边。现在看来，两边都确定数据类型最好，像这样<code>long sum = (long)nums[i] + nums[j] + nums[k];</code>。</p>
</li>
</ul>
<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>思路1</p>
<p>考虑直接删除重复元素，则需要在遍历中改变 vector 长度。采用逆序遍历避免 index 错位。<code>erase</code> 函数的时间复杂度是 $O(n)$，效率不高。</p>
</li>
<li><p>思路2</p>
<p>利用双指针，在遍历过程中将非重复的元素值赋值到前 k 位。</p>
</li>
</ul>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 思路1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i<span class="hljs-number">-1</span>]) &#123;<br>                nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 思路2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != nums[l]) nums[++l] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ++l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-4"><a href="#心得-4" class="headerlink" title="心得"></a>心得</h3><ul>
<li>关注在遍历中改变 array 长度的操作</li>
</ul>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>两种思路，都是通过双指针实现。</p>
<ol>
<li>将原数组视作输出数组，遍历数组，将不等于 <code>val</code> 的元素排列在输出数组中（即按序排在原数组头部），这是因为输出数组的长度一定小于原数组，因此覆盖操作不会影响遍历操作。</li>
<li>将原数组中等于 <code>val</code> 的元素替换掉。用左指针从头开始检索出等于 <code>val</code> 的元素，用右指针从尾开始检索出不等于 <code>val</code> 的元素替换它。</li>
</ol>
<p>注意，方法1 是「覆盖」，方法2 是「替换」。因此在某些情况下 2 比 1 耗时少。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != val) nums[index++] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-5"><a href="#心得-5" class="headerlink" title="心得"></a>心得</h3><p>本题的分析中，两个方法的对比是比较有意思的。题目要求在「原数组」上操作，那么该如何看待和处理原数组的值？「覆盖」思路简单地忽略掉原先的值，而「替换」思路则将值分为 <code>==val</code> 和 <code>!=val</code> 两类。后者显然更细致，也更考验思维的深度。</p>
<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>本题的数学模型并不直观。分析中，笔者给出以下直观的「推论」（显然在做题中无须对其证伪进行严谨证明）：</p>
<ul>
<li>给定一个排列，通过交换其「靠前的较小数字」和「靠后的较大数字」，必然得到一个「字典序更大的排列」；反之亦然。</li>
<li>给定一个排列的前缀，「满足前缀的排列」中的最小排列，它的非前缀部分必然为「非递减数列」；反之亦然。</li>
</ul>
<p>基于以上推论，笔者给出如下操作逻辑：</p>
<ol>
<li>从后往前遍历，找出第一个「在已遍历的数列中非最大」的数，作为待交换的「靠前的较小数字」。</li>
<li>在已遍历的数中找出「比待交换的数大的数」中最小的数，作为「靠后的较大数字」。</li>
<li>交换两者。</li>
<li>将交换后「较大数字」之后的序列排列为「非递减数列」。</li>
</ol>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[index - <span class="hljs-number">1</span>] &gt;= nums[index]) --index;<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[index - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[index - <span class="hljs-number">1</span>], nums[i]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + index, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-6"><a href="#心得-6" class="headerlink" title="心得"></a>心得</h3><ul>
<li><strong>字典序</strong>可以简单理解为按照前缀排序的思路。</li>
</ul>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>二分查找实现对数时间。</p>
<p>二分后，如果是递增序列，则套用基础的二分逻辑。如果是旋转过的数列，则根据mid所处的位置进行逻辑判断。</p>
<p><strong>优化思路</strong>：二分后必然有一个递增数列和一个旋转数列，且两者的数域范围不相交。通过判断target是否在递增数列中来移动双指针。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left  = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (target == nums[mid]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[right]) &#123;<br>                <span class="hljs-keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;<br>                <span class="hljs-keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt; nums[right]) right = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt; nums[left]) left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-7"><a href="#心得-7" class="headerlink" title="心得"></a>心得</h3><p>二分的最直观理解：二分后判断目标可能出现在两者之一，从而缩减范围。从最直观、简单的思路出发来解决问题，是算法领域的进阶技巧，这需要不断精炼自己的思维。</p>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>一种思路是通过二分法分别找到target的开始位置和结束位置。</p>
<p>由于对寻找的目标有先后要求，在循环中找到target后不能直接退出循环。而是更新信息并继续缩小范围。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                ans[<span class="hljs-number">0</span>] = mid;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        l = <span class="hljs-number">0</span>;<br>        r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                ans[<span class="hljs-number">1</span>] = mid;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-8"><a href="#心得-8" class="headerlink" title="心得"></a>心得</h3><p>强化二分法缩小范围的作用。</p>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>用数学语言描述题目：<code>nums[ans-1] &lt; target &lt;= nums[ans]</code>。</p>
<p>从而得到二分法的二分逻辑。</p>
<p>考虑边界情况：target 大于所有 nums 中元素。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= target) &#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-9"><a href="#心得-9" class="headerlink" title="心得"></a>心得</h3><ul>
<li>数学化理解问题</li>
<li>调试时枚举边界情况</li>
</ul>
<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/valid-sudoku/">36. 有效的数独</a></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>关键在于对重复元素的判断。通过遍历判断元素重复次数往往比较复杂。直接记录元素的出现次数只需要一次遍历。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 基于哈希表记录每行、每列、每宫中每个数字的出现次数，需要一次遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> col[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> num = board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (row[i][num]++ || col[j][num]++ || box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][num]++) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 基于位运算修改</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row[<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> col[<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> arr = <span class="hljs-number">1</span> &lt;&lt; (board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (row[i] &amp; arr || col[j] &amp; arr || box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>] &amp; arr) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                row[i] |= arr;<br>                col[j] |= arr;<br>                box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>] |= arr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-10"><a href="#心得-10" class="headerlink" title="心得"></a>心得</h3><ol>
<li>哈希表（散列表）是一种抽象数据结构，实现上通常使用一个一维数组实现。哈希表的目的是解决编程过程中的存储、访问。</li>
<li>想要判断重复，可以通过一次遍历，统计各个元素的出现次数。</li>
<li>二进制状态压缩，是指将一个长度为m的bool数组用一个m位二进制整数表示并储存的方法。之后可以通过位运算进行操作。</li>
</ol>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>回溯算法。利用递归。</p>
<ul>
<li><p>初步思路：按照遍历顺序进行递归。</p>
<blockquote>
<p>问题：需要判断是否空格，dfs失败后分类讨论如何返回，情况复杂，难以理顺。</p>
</blockquote>
</li>
<li><p>预处理简化v_1：预先将所有空格统计，直接遍历所有空格进行递归。</p>
<blockquote>
<p>问题：利用上一题的代码验证有效性，在剪枝操作部分没有撤销对board的更改，导致后续验证失败。修改代码后成功。</p>
</blockquote>
</li>
<li><p>逻辑优化v_2：注意到上一题的数独有效性验证代码是针对整个数独，而本题代码中需要的是对单个空格进行验证，只需要对该空格所在的横行、纵行、九宫进行验证。</p>
</li>
<li><p>二进制状态压缩v_3：利用二进制状态压缩对布尔数组简化，节省空间，提高效率。</p>
</li>
<li><p>二进制状态压缩优化：在官方题解中，还可以通过位运算代替1~9的遍历，直接选取符合要求的数进行递归。通过位运算提高了效率。</p>
</li>
<li><p>逻辑优化：可以在递归前，先将空白格只有唯一的数可填的情况处理掉。时间和空间上各有取舍，并非纯优化。</p>
</li>
</ul>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) que.<span class="hljs-built_in">emplace_back</span>(i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == que.<span class="hljs-built_in">size</span>()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i = que[pos].first;<br>        <span class="hljs-type">int</span> j = que[pos].second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= <span class="hljs-number">9</span> &amp;&amp; !valid; t++) &#123;<br>            board[i][j] = t + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (ifValid(board)) <span class="hljs-built_in">dfs</span>(board, pos + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!valid) board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ifValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> col[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-type">int</span> box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> num = board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (row[i][num]++ || col[j][num]++ || box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][num]++) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    <span class="hljs-type">bool</span> row[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>    <span class="hljs-type">bool</span> col[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br>    <span class="hljs-type">bool</span> box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>] = &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    que.<span class="hljs-built_in">emplace_back</span>(i, j);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> num = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">1</span>;<br>                    row[i][num] = <span class="hljs-literal">true</span>;<br>                    col[j][num] = <span class="hljs-literal">true</span>;<br>                    box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][num] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == que.<span class="hljs-built_in">size</span>()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i = que[pos].first;<br>        <span class="hljs-type">int</span> j = que[pos].second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">9</span> &amp;&amp; !valid; t++) &#123;<br>            <span class="hljs-keyword">if</span> (row[i][t] || col[j][t] || box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t]) <span class="hljs-keyword">continue</span>;<br>            board[i][j] = t + <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>;<br>            row[i][t] = <span class="hljs-literal">true</span>;<br>            col[j][t] = <span class="hljs-literal">true</span>;<br>            box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(board, pos + <span class="hljs-number">1</span>);<br>            row[i][t] = <span class="hljs-literal">false</span>;<br>            col[j][t] = <span class="hljs-literal">false</span>;<br>            box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>][t] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v_3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> valid = <span class="hljs-literal">false</span>;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    <span class="hljs-type">int</span> row[<span class="hljs-number">9</span>] = &#123;&#125;;<br>    <span class="hljs-type">int</span> col[<span class="hljs-number">9</span>] = &#123;&#125;;<br>    <span class="hljs-type">int</span> box[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    que.<span class="hljs-built_in">emplace_back</span>(i, j);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> tmp = <span class="hljs-number">1</span> &lt;&lt; (board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>);<br>                    <span class="hljs-built_in">Xor</span>(i, j, tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Xor</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> tmp)</span> </span>&#123;<br>        row[i] ^= tmp; col[j] ^= tmp; box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>] ^= tmp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> pos)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == que.<span class="hljs-built_in">size</span>()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i = que[pos].first;<br>        <span class="hljs-type">int</span> j = que[pos].second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">9</span> &amp;&amp; !valid; t++) &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">1</span> &lt;&lt; t;<br>            <span class="hljs-keyword">if</span> (row[i] &amp; tmp || col[j] &amp; tmp || box[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>] &amp; tmp) <span class="hljs-keyword">continue</span>;<br>            board[i][j] = t + <span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-built_in">Xor</span>(i, j, tmp);<br>            <span class="hljs-built_in">dfs</span>(board, pos + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">Xor</span>(i, j, tmp);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h3 id="心得-11"><a href="#心得-11" class="headerlink" title="心得"></a>心得</h3><ul>
<li><p>在代码的同一层级处，如果出现较多的条件分类以至于推导不动，建议退回上一层级，预先处理掉部分简单特例，保持同一层级的功能简单纯粹。</p>
</li>
<li><p>本题中在for遍历中添加了判断条件valid，用于终止递归。非常巧妙，这是因为本题中递归返回的位置是上一层的for循环，可以直观地终止循环递归。</p>
</li>
<li><p>位运算技巧：</p>
<ul>
<li>利用运算<code>^</code>可将第i位反转。</li>
<li>利用<code>b&amp;(-b)</code>获得b二进制中最低位的1</li>
<li>二进制压缩中，只关注int类型的二进制尾部几位，一旦按位取反，高位也会受影响，需要进行按位与运算来抵消高位的影响。</li>
</ul>
</li>
</ul>
<h1 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/count-and-say/">38. 外观数列</a></h1><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        string str = <span class="hljs-string">&quot;11&quot;</span>;<br>        string num;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>            num = str;<br>            str = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; num.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (j == num.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || num[j] != num[j + <span class="hljs-number">1</span>]) &#123;<br>                    size = j - index + <span class="hljs-number">1</span>;<br>                    str += <span class="hljs-built_in">to_string</span>(size);<br>                    str += num[j];<br>                    index = j + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-12"><a href="#心得-12" class="headerlink" title="心得"></a>心得</h3><ul>
<li><code>size_t</code> 是一个用于表示对象大小（尤其是数组大小）的数据类型，具体来说，<code>size_t</code> 的大小通常被设计成与指针的大小相同，这样可以确保它足够大以容纳任何可能的数组大小。<code>size_t</code> 常用于与内存分配和数组索引相关的场景，因为它可以确保能够容纳大量的数据。</li>
<li>for循环考虑较多continue直接换while循环，有时可以简化思路。</li>
</ul>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><ul>
<li>通过回溯算法列举所有解法组合。</li>
<li>通过预先排序，在for遍历中及时return来剪枝。</li>
</ul>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = &#123;&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; group = &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> diff, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (diff &lt; candidates[i]) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff == candidates[i]) &#123;<br>                group.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>                ans.<span class="hljs-built_in">push_back</span>(group);<br>                group.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                group.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>                <span class="hljs-built_in">dfs</span>(candidates, diff - candidates[i], i);<br>                group.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-13"><a href="#心得-13" class="headerlink" title="心得"></a>心得</h3><ul>
<li>列出所有解法的问题通常可以用「回溯法」解决，回溯往往是DFS思路，通过「剪枝」操作降低复杂度。</li>
<li>回溯法的关键在于返回上一决策层时需要销毁目前的更改，这往往体现在dfs函数中调用dfs函数的上下文，通常是上文做出更改，dfs下方撤销更改。</li>
</ul>
<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><ul>
<li>题目允许同一个组合中出现不同但值相等的数字，因此在dfs时无须关心上一决策层选用的数字。</li>
<li>由于每个数字在一个组合中只能使用一次，因此dfs转移到下一决策层时需要增加index，即从下一个数字开始dfs。</li>
<li>解集不能包含重复的组合，因此在同一决策层for循环平移时，需要保证下一个遍历的数和当前已经分析过的数值不相等。</li>
</ul>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = &#123;&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; group = &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> diff, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (diff &lt; candidates[i]) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff == candidates[i]) &#123;<br>                group.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>                ans.<span class="hljs-built_in">push_back</span>(group);<br>                group.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                group.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>                <span class="hljs-built_in">dfs</span>(candidates, diff - candidates[i], i + <span class="hljs-number">1</span>);<br>                group.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="心得-14"><a href="#心得-14" class="headerlink" title="心得"></a>心得</h3><ul>
<li><p>列举所有解法的问题往往通过构建一个基于排列组合的树，第i层节点可理解为第i个位置选择候选集合中的一个元素。因此笔者用决策层来表示某一层的任意节点，通过对其与上下决策层的关系来解释思路。</p>
<p>体现在代码中，即一个dfs函数为一个决策层，dfs函数中嵌套的dfs函数为其下一个决策层。</p>
</li>
</ul>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h2><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>直观想法v_1：先用哈希表统计所有正整数，然后从小到大开始判断是否有不在哈希表中的正整数。</p>
<blockquote>
<p>由于用了哈希表统计数组正整数，因此空间复杂度为$O(n)$</p>
</blockquote>
</li>
<li><p>数学分析v_2：对于长n的数组，符合条件的整数必然在[1,n+1]中，因此，可以在遍历数组时，将[1,n]范围的元素移位到对应的下标处。最终与下标不匹配的为不属于数组的正数。显然，如果全都匹配，则为n+1。</p>
</li>
<li><p>标记法v_3：上一条分析中，实际上下标就可以表征一个正整数，采用swap是为了不覆盖原数组的数据。通过负号标记可以替代swap，简化思路。</p>
</li>
</ul>
<h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v_1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            mySet.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(mySet.<span class="hljs-built_in">count</span>(ans)) &#123;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v_2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; nums[i] &amp;&amp; nums[i] &lt; n + <span class="hljs-number">1</span> &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != j + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; num: nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1</span>) num = n + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (num &lt; n + <span class="hljs-number">1</span>) nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; nums[i]) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-15"><a href="#心得-15" class="headerlink" title="心得"></a>心得</h3><ul>
<li>如果你需要按照一定顺序（默认是按元素的键值升序）访问元素，可以使用 <code>std::set</code>。</li>
<li>如果你更关心查找、插入和删除的性能，而不在乎元素的顺序，可以考虑使用 <code>std::unordered_set</code>，它具有更快的查找速度。</li>
<li>限制空间复杂度的算法题，可以考虑复用题目提供的数据的空间。</li>
<li>尽量用标准的函数实现功能，如swap。</li>
<li>正int数组可以通过负号实现间接标记。</li>
</ul>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>从高度1开始，统计每层的容量。测试结果：时间复杂度和数组最大值有关，效率太低。</p>
</li>
<li><p>双指针法v_1：</p>
<ul>
<li>考虑一个近似为碗状曲线的”水坑“，对于该水坑中处于水底的柱子来说，它能够提供的“水深”只取决于左右两根边界柱子中的较矮的柱子。因此，当遍历一个可能「处于水底的的柱子」时，只需要知道它之前、之后的「较矮的边界柱子」就能计算它提供的水深。</li>
<li>什么是「处于水底的的柱子」：比它前一个/后一个柱子矮的柱子。</li>
<li>「边界柱子」的特征：左/右边界柱子的左/右边的所有柱子应当不高于它，否则它应该是「处于水底的的柱子」。</li>
<li>使用双指针，从左右到中间遍历。显然，可以通过记录左指针移动过程中的最大值作为当前的备选「左边界柱子」。左指针移动后高度降低后，即可视作「处于水底的的柱子」。右指针同理。</li>
<li>以左指针为例，当找到一个「处于水底的的柱子」时，备选「左边界柱子」显然是它的「左边界柱子」（因为遍历过左边所有柱子）；但备选「右边界柱子」是一定是它的「右边界柱子」？</li>
<li>注意到只需要知道「较矮的边界柱子」即可，因此只需要柱子右边的「边界柱子」一定不低于已知的「左边界柱子」即可。显然，如果中间有未遍历的边界柱子，它一定不矮于备选「右边界柱子」。因此只要确保「左边界柱子」不高于备选「右边界柱子」即可满足条件。</li>
<li>因此，每次选择备选「边界柱子」较矮的一侧指针进行更新，即可满足条件。</li>
<li>注意到上述分析是从一个预设的问题情景发散得到一个算法，从应用角度上还可以从算法出发，尝试举反例来反证其可行性。</li>
</ul>
</li>
<li><p>动态规划v_2：对于第$i$个柱子，它的上面的水面高度取决于两边最大高度中的较小高度。注意到对不同的柱子，两边的最大高度是可能不同的。最朴素的思想是每次向左右两侧遍历。</p>
<p>注意到对于不同的柱子，这个遍历过程是存在重叠的。即某一个遍历过程可能是另一个遍历过程的子问题。因此可以用动态规划来得到每个柱子对应的左右最高柱子。</p>
</li>
<li><p>单调栈v_3：</p>
<ul>
<li>按照for循环遍历数组，直观的例子是找到一组“高-低-高”。然而，如果仅根据两个高柱子和中间矮柱子来计算容量，可能只是真正容量中的一部分（类比大坑中的小洼）。</li>
<li>考虑一种情况：现发现（i,j）区间为较低的柱子，可容纳(j - i - 1) * deep体积的水。而实际上这是真正容量中的一部分，为了继续计算剩余的容量，可以认为已计算的容量空间被填充，成为新的「水底」。需要得知较矮的「边界柱子」之外是否存在更高的「边界柱子」，如果存在，就可以构建一个新的「水坑」。以此类推，直到数组边界。</li>
<li>在for循环遍历中，未遍历的柱子可以在遍历过程中寻找新的「边界柱子」，那如何存储已遍历的柱子中潜在的「边界柱子」？注意到潜在的「边界柱子」需要高于当前的「边界柱子」。因此，可以用单调减栈来记录遍历结果。</li>
</ul>
</li>
</ul>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!height.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> max_left = height[left];<br>        <span class="hljs-type">int</span> max_right = height[right];<br>        <span class="hljs-type">bool</span> flag = height[left] &gt; height[right];<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> m = <span class="hljs-built_in">min</span>(max_left, max_right);<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-keyword">if</span> (max_right &lt; height[right]) max_right = height[right];<br>                <span class="hljs-keyword">else</span> ans += m - height[right];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (max_left &lt; height[left]) max_left = height[left];<br>                <span class="hljs-keyword">else</span> ans += m - height[left];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (height[left] &lt;= height[right]) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                right--;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v_2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!height.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left_max</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right_max</span><span class="hljs-params">(n)</span></span>;<br>        left_max[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        right_max[n<span class="hljs-number">-1</span>] = height[n - <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            left_max[i] = <span class="hljs-built_in">max</span>(left_max[i - <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            right_max[i] = <span class="hljs-built_in">max</span>(right_max[i + <span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> deep = <span class="hljs-built_in">min</span>(left_max[i], right_max[i]) - height[i];<br>            ans += (deep &gt; <span class="hljs-number">0</span>) ? deep : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v_3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; height[stk.<span class="hljs-built_in">top</span>()] &lt; height[i]) &#123;<br>                <span class="hljs-type">int</span> bottom = height[stk.<span class="hljs-built_in">top</span>()]; stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                    ans += (<span class="hljs-built_in">min</span>(height[i], height[stk.<span class="hljs-built_in">top</span>()]) - bottom) * (i - stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-16"><a href="#心得-16" class="headerlink" title="心得"></a>心得</h3><ul>
<li>动态规划：它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算。</li>
<li>C++动态数组建议用vector实现。</li>
<li>涉及到下标的代码，一定要思考是否存在下标越界的情况。</li>
</ul>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>典型的动态规划问题v_1：</p>
<p>$times[n - 1] = min_{0\leq i&lt; n-1; i+nums[i] \geq n-1}{times[i] + 1}$</p>
</li>
<li><p>贪心v_2：本题并非一定要用DP。事实上，如果设定每个点只能向前跳最大长度，而非区间，则只能用DP。以从下标 0 起跳为例，假设能跳到范围 [0, i]，现比较该范围中下标能跳到的下一个下标范围，发现它们会被其中跳的最远的一个下标包含。因此只需要选择这个下标作为下一个跳跃点。即，当前的最优解一定导向下一个最优解，因此可以使用贪心算法。</p>
</li>
</ul>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(n, n)</span></span>;<br>        times[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j + nums[j] &gt;= i &amp;&amp; times[j] + <span class="hljs-number">1</span> &lt; times[i]) times[i] = times[j] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> times[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i + nums[i] &lt; n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> next = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= i + nums[i]; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j + nums[j] &gt; next + nums[next]) next = j; <br>            &#125;<br>            i = next;<br>            times++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> times + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-17"><a href="#心得-17" class="headerlink" title="心得"></a>心得</h3><ul>
<li>贪心是DP的特例，遇到DP问题可以考虑是否能通过贪心解决。</li>
</ul>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="external nofollow noopener noreferrer" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><ul>
<li>回溯法v_1</li>
<li>时空优化v_2：<ul>
<li>在v_1中，构建了一个哈希表记录已添加的元素、一个vector记录新的排列。每次添加删除都需要对哈希表和vector同时进行，需要找到更简单的方案来记录已经添加的元素、维持当前的排列。</li>
<li>在算法题中，一种常见的节省空间的方案是利用题目输入提供的数据空间。因此可以通过交换元素位置来构建排列。</li>
<li>惊喜的是，在交换元素后，可以发现已经添加的元素和其他元素可以分割在数组两侧。</li>
<li>同时，在实践中可以发现，由于通过下标来区分，无须对整个数组进行遍历，进一步节省时间。</li>
</ul>
</li>
</ul>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; myset;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>            <span class="hljs-keyword">if</span> (myset.<span class="hljs-built_in">count</span>(n)) <span class="hljs-keyword">continue</span>;<br>            tmp.<span class="hljs-built_in">push_back</span>(n);<br>            myset.<span class="hljs-built_in">insert</span>(n);<br>            <span class="hljs-built_in">dfs</span>(nums);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>            myset.<span class="hljs-built_in">erase</span>(n);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// v_2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == len) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; len; i++) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[index], nums[i]);<br>            <span class="hljs-built_in">backtrack</span>(nums, index + <span class="hljs-number">1</span>, len);<br>            <span class="hljs-built_in">swap</span>(nums[index], nums[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="心得-18"><a href="#心得-18" class="headerlink" title="心得"></a>心得</h3><ul>
<li>注意到回溯算法dfs函数的构建有一定规律：<ul>
<li>返回判断：当搜索到一个结果，直接返回，无须销毁这个结果对应的数据结构</li>
<li>遍历：一般通过for循环遍历下一个可能的元素</li>
<li>进入下一决策层：找到合适的元素后，进行下一层dfs</li>
<li>退出下一决策层：从下一决策层返回有两种情况：找到一个解、无解；无论哪种情况，在返回后都需要销毁之前加入的元素</li>
</ul>
</li>
<li>C++11中<code>vector</code>类<code>emplace_back()</code>函数只调用构造函数，而<code>push_back()</code>调用了构造函数和移动构造函数，前者消耗更少。</li>
</ul>

                
              </div>
            
            <hr>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/" class="print-no-link">#算法，不定期更新</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>leetcode 刷题记录</div>
      <div>https://01warpdrive.github.io/posts/c862.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>舣星</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/" rel="external nofollow noopener noreferrer">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/30b1.html" title="人工智能安全技术笔记（1）概论">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">人工智能安全技术笔记（1）概论</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/820f.html" title="Hyper-V禁用指南">
                        <span class="hidden-mobile">Hyper-V禁用指南</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="external nofollow noopener noreferrer"><span>Fluid</span></a> <br> <span> © 2022 - 2023  <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/01WarpDrive">舣星</a> |  All rights reserved. </span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script>
  <link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css">

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script>
<script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script>
<script src="/js/events.js"></script>
<script src="/js/plugins.js"></script>


  <script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script src="/js/img-lazyload.js"></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>

  <script src="/js/local-search.js"></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script src="/js/boot.js"></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
