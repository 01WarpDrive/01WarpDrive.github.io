<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SJTU_ACMOJ 1173. 一道排序题</title>
      <link href="/posts/ca6a.html"/>
      <url>/posts/ca6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="SJTU-ACMOJ-1173-一道排序题"><a href="#SJTU-ACMOJ-1173-一道排序题" class="headerlink" title="SJTU_ACMOJ 1173. 一道排序题"></a>SJTU_ACMOJ 1173. 一道排序题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>萌萌的死神最讨厌数学题了，讨厌讨厌真是讨厌死了。</p><p>这不，死神一生的好朋友gingkgo又拿数学题来难为他了。接到题目后，死神原本眉飞色舞的脸瞬间石化了，真是讨厌死了。</p><p>幸亏还有你们这群好朋友呢！如果没有的话，事情才不知道会怎么样呢！</p><p>现在问题来了，给你2个数组a[]和b[]，他们有相同的长度n，你可以任意交换一个数组中的元素，我们定义函数<br>$x=∑a[i]∗b[i]$</p><p>现在，死神请你告诉他，x最大可以取到多少，最小可以取到多少？真是讨厌死了。</p><span id="more"></span><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行一个整数n，代表数组的长度；</p><p>第二行数组a，最后一行数组b；</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出两个整数代表答案；</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><p>2<br>10 3<br>10 9</p><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><p>127 120</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于40%的数据，$n \leq 10n≤10$；</p><p>对于100%的数据，$n \leq 100000n≤100000 ，1 \leq a[i] , b[i] \leq 1000001≤a[i],b[i]≤100000$；</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="抽象归纳"><a href="#抽象归纳" class="headerlink" title="抽象归纳"></a>抽象归纳</h3><p>一个数组理解为不可变的数据，另一个数组理解为一组权重值。<br>寻找使得综合最小的权重匹配。</p><blockquote><p>很遗憾笔者阅历有限，没能为这种问题找到专业的术语。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>说实话，这题的出题者很善良。标题写得清清楚楚，是“一道排序题”。顺着这个思想想下去，很容易意识到，可以先将两个数组按照从小到大排序。然后按顺序依次相乘得到最大值，按逆序依次相乘得到最小值。</p><h3 id="回顾排序算法"><a href="#回顾排序算法" class="headerlink" title="回顾排序算法"></a>回顾排序算法</h3><p>接下来笔者需要找到一种时间复杂度较低的算法。铛铛挡！它就是快速排序。</p><p>快速排序的基本思想是在序列中找一个数据元素，将所有数据分为小于它和大于它两组。对这两组继续上述算法。显然，是以递归形式实现。</p><p>快排的难点可能在于如何划分。笔者简单解释下其中一个简单的方式。该方法的算法思想是对撞双指针（双指针是很有意思的算法思想，以后笔者会专门写个系列）。</p><ul><li>首先，将low中的元素放在变量k中</li><li>然后从右到左检查，如果high位置的值大于k，则该值不变，high指针左移</li><li>如果high位置的值小于k，则将它放入low位置，该位置空出；</li><li>low指针从左到右检查，之后同理重复</li><li>直到low和high重叠，将k放入该位置</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入待排序列，左指针、右指针；</span></span><br><span class="line"><span class="comment"> * 这里的指针并非C++意义上的指针，而算法思想上的指针，笔者喜欢这样的描述方式；</span></span><br><span class="line"><span class="comment"> * 在该函数中，左右指针为左右下标，用于表示子序列；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>; <span class="comment">// 写递归先写终止条件</span></span><br><span class="line">    mid = <span class="built_in">divide</span>(a, low, high); <span class="comment">// 划分函数</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, low, mid - <span class="number">1</span>); <span class="comment">// 左排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, mid + <span class="number">1</span>, high); <span class="comment">// 右排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在乱序序列中挑一个标准元素有多种方法；</span></span><br><span class="line"><span class="comment"> * 理想情况下应当选择中位数；</span></span><br><span class="line"><span class="comment"> * 本示例选择序列第一个元素；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = a[low]; <span class="comment">// 标准元素</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= k) --high; <span class="comment">// 从右到左扫描</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123; a[low] = a[high]; ++low; &#125; <span class="comment">// 互换</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= k)++low; <span class="comment">// 从左到右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123; a[high] = a[low]; --high; &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (low != high);</span><br><span class="line">    a[low] = k;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在掌握了快排后，笔者惯例性地考虑数据范围。显然单个元素在int范围；但最终计算得到结果会大于int范围，因此笔者直接用long long类型存储计算结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在乱序序列中挑一个标准元素有多种方法；</span></span><br><span class="line"><span class="comment"> * 理想情况下应当选择中位数；</span></span><br><span class="line"><span class="comment"> * 本示例选择序列第一个元素；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = a[low]; <span class="comment">// 标准元素</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[high] &gt;= k) --high; <span class="comment">// 从右到左扫描</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123; a[low] = a[high]; ++low; &#125; <span class="comment">// 互换</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[low] &lt;= k)++low; <span class="comment">// 从左到右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123; a[high] = a[low]; --high; &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (low != high);</span><br><span class="line">    a[low] = k;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入待排序列，左指针、右指针；</span></span><br><span class="line"><span class="comment"> * 这里的指针并非C++意义上的指针，而算法思想上的指针，笔者喜欢这样的描述方式；</span></span><br><span class="line"><span class="comment"> * 在该函数中，左右指针为左右下标，用于表示子序列；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>; <span class="comment">// 写递归先写终止条件</span></span><br><span class="line">    mid = <span class="built_in">divide</span>(a, low, high); <span class="comment">// 划分函数</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, low, mid - <span class="number">1</span>); <span class="comment">// 左排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, mid + <span class="number">1</span>, high); <span class="comment">// 右排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span>* a, * b;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(b, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max = <span class="number">0</span>; <span class="comment">// 单个数据元素在int范围内，积的和可能大于int</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max += (<span class="type">long</span> <span class="type">long</span>)a[i] * (<span class="type">long</span> <span class="type">long</span>)b[i];</span><br><span class="line">        min += (<span class="type">long</span> <span class="type">long</span>)a[i] * (<span class="type">long</span> <span class="type">long</span>)b[n<span class="number">-1</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACMOJ </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网资源</title>
      <link href="/posts/bc95.html"/>
      <url>/posts/bc95.html</url>
      
        <content type="html"><![CDATA[<h1 id="互联网资源"><a href="#互联网资源" class="headerlink" title="互联网资源"></a>互联网资源</h1><p>近十几年来，互联网商业化加速。在逐利的泥沼中，很多优质资源被掩盖在海量的数据里。本文章收录了一些互联网资源，并不定期维护更新。</p><p>此外，如果相关负责人认为笔者行为涉及侵权，请联系笔者删除。</p><span id="more"></span><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><a href="https://kaifa.baidu.com/">开发者搜索，编程相关</a><blockquote><p>百度难得的良心网站，搜索的结果基本上集中在各类开发者网站</p></blockquote></li></ul><h3 id="多媒体制作"><a href="#多媒体制作" class="headerlink" title="多媒体制作"></a>多媒体制作</h3><ul><li><a href="https://bigjpg.com/">图片无损放大修复</a></li><li><a href="https://www.pickwant.com/#/home">图片背景消除抠图</a></li><li><a href="https://www.uupoop.com/ico/">icon 图标制作</a> </li><li><a href="https://www.iconfont.cn/">矢量图标制作下载</a></li><li><a href="http://www.pptbz.com/">PPT模板下载</a></li><li><a href="https://undraw.co/illustrations">图片下载：紫色简约卡通人</a></li><li><a href="https://www.aigei.com/">综合素材</a></li><li><a href="https://beecut.cn/online-video-editor">在线视频处理</a></li><li><a href="https://wall.alphacoders.com/?lang=Chinese">壁纸</a></li></ul><h3 id="媒体资源"><a href="#媒体资源" class="headerlink" title="媒体资源"></a>媒体资源</h3><ul><li><p><a href="https://aidi.tv/">影视电影电视剧</a></p></li><li><p><a href="https://xunlei8.cc/">迅雷电影下载</a></p></li><li><p><a href="https://www.yhdmp.cc/">动漫</a></p></li><li><p><a href="https://tool.liumingye.cn/music/?page=searchPage#/">在线音乐下载</a></p><blockquote><p>一个在线音乐平台，能找到不少音乐并下载，可以替代音乐软件</p></blockquote></li></ul><h3 id="软件资源下载"><a href="#软件资源下载" class="headerlink" title="软件资源下载"></a>软件资源下载</h3><h3 id="数据搜集"><a href="#数据搜集" class="headerlink" title="数据搜集"></a>数据搜集</h3><ul><li><a href="http://hao.199it.com/">大数据搜集</a></li><li><a href="https://www.cnbksy.com/">全国报刊索引</a></li></ul><h3 id="现实生活"><a href="#现实生活" class="headerlink" title="现实生活"></a>现实生活</h3><ul><li><a href="https://www.ehow.com/13771258/diy-spring-welcome-mat">家庭技巧/制作/DIY</a></li></ul><h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><h3 id="信息表达工具"><a href="#信息表达工具" class="headerlink" title="信息表达工具"></a>信息表达工具</h3><p>*<strong>win</strong></p><ul><li>git图制作： <a href="https://juejin.cn/post/6844904042448044045">ScreenToGif</a></li></ul><h3 id="文本辅助"><a href="#文本辅助" class="headerlink" title="文本辅助"></a>文本辅助</h3><ul><li>英文语法检测：<a href="https://www.grammarly.com/">grammarly(win)</a><blockquote><p>方便好用，可以有选择地自动修改，甚至都不用注册；</p></blockquote></li></ul><h3 id="跨设备交互"><a href="#跨设备交互" class="headerlink" title="跨设备交互"></a>跨设备交互</h3><ul><li><a href="https://github.com/YanxinTang/clipboard-online/blob/master/README_zh.md">基于同一局域网共享剪切板</a>  <a href="https://blog.csdn.net/axutongxue/article/details/119801830">教程</a></li></ul><h3 id="网络环境改善"><a href="#网络环境改善" class="headerlink" title="网络环境改善"></a>网络环境改善</h3><ul><li><a href="https://www.dogfight360.com/blog/">部分网站软件host修改提速</a></li></ul><h3 id="音乐相关"><a href="#音乐相关" class="headerlink" title="音乐相关"></a>音乐相关</h3><ul><li><a href="https://musescore.org/zh-hans/download/musescore.msi">打谱软件musescore</a></li><li><a href="https://www.everyonepiano.cn/Software-7-EOP-%E7%AE%80%E8%B0%B1%E5%A4%A7%E5%B8%88.html">简谱制作EOP</a></li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p><strong>Android</strong></p><ul><li>阅读工具：厚墨<blockquote><p>简洁无广告，支持多种格式电子书</p></blockquote></li></ul><h3 id="现实生活-1"><a href="#现实生活-1" class="headerlink" title="现实生活"></a>现实生活</h3><ul><li><a href="https://www.bypass.cn/">抢火车票</a><blockquote><p> 可定时抢，是特殊时期的必备软件</p></blockquote></li></ul><h1 id="不传播"><a href="#不传播" class="headerlink" title="不传播"></a>不传播</h1><blockquote><p>这些灰色资源不应该被广为传播。鉴于目前博客仍处于起步阶段，没有大量访客，姑且放上来。</p></blockquote><ul><li><a href="https://www.duyaoss.com/archives/3/">机场评测</a></li><li><a href="https://izm.rocks/#/dashboard">芝麻vpn</a></li></ul><h1 id="网上copy，暂未整理"><a href="#网上copy，暂未整理" class="headerlink" title="网上copy，暂未整理"></a>网上copy，暂未整理</h1><p>【模板库】</p><ol><li>演示星球：<a href="http://www.pop-ppt.com/">www.pop-ppt.com</a></li><li>微软 OfficePLUS：<a href="http://www.officeplus.cn/">www.officeplus.cn</a><br>【图片库】</li><li>免费商用 Unsplash：<a href="http://www.unsplash.com/">www.unsplash.com</a></li><li>免抠图透明素材 pngpix：<a href="http://www.pngpix.com/">www.pngpix.com</a></li><li>高清人、物PNG素材 MOOSE：<a href="https://igoutu.cn/photos">https://igoutu.cn/photos</a><br>【在线编辑】</li><li>人工智能绘画AutoDraw：<a href="http://www.autodraw.com/">www.autodraw.com</a></li><li>流体背景Fluid Simulation：paveldogreat.github.io/WebGL-Fluid-Simulation</li><li>纹理背景RUSSFUSS：russfuss.com</li><li>液态渐变星球 Nebula Artefact：<a href="https://alteredqualia.com/xg/examples/nebula_artefact.html">https://alteredqualia.com/xg/examples/nebula_artefact.html</a></li><li>抽象背景Bg-Painter：bg-painter.com</li><li>渐变色 Mesh Gradient：meshgradient.com</li><li>在线作图（流程图、架构图、思维导图等）ProcessOn：<a href="http://www.processon.com/">www.processon.com</a></li><li>镝数图表：dycharts.com</li><li>花火数图（数据短视频）：hanabi.cn</li><li>在线编辑图片：iloveimg.com/zh-cn</li><li>免费在线抠图：fococlipping.com</li><li>免费样机生成器 Free Mockup Generator：mockups.pixeltrue.com<br>18.在线文本格式转换 ACONVERT：aconvert.come</li></ol>]]></content>
      
      
      <categories>
          
          <category> 资源共享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源共享 </tag>
            
            <tag> 不定期更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床测试</title>
      <link href="/posts/f2eb.html"/>
      <url>/posts/f2eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="图床测试"><a href="#图床测试" class="headerlink" title="图床测试"></a>图床测试</h1><p><img src="https://notes.sjtu.edu.cn/uploads/upload_572a421050d5af848e688fc45cc1a314.png"></p><span id="more"></span><p><img src="https://notes.sjtu.edu.cn/uploads/upload_458393b775c56a99befb35f40b4a55d6.png"><br><img src="https://notes.sjtu.edu.cn/uploads/upload_7721f113d4edf88a5f967dbc8b4006f4.png"><br><img src="https://notes.sjtu.edu.cn/uploads/upload_b9b83640380d087e75f74fbe9c883e26.png"></p>]]></content>
      
      
      <categories>
          
          <category> 博客测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>darknet 训练 yolov4-tiny模型</title>
      <link href="/posts/a6dc.html"/>
      <url>/posts/a6dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="darknet-训练-yolov4-tiny模型"><a href="#darknet-训练-yolov4-tiny模型" class="headerlink" title="darknet 训练 yolov4-tiny模型"></a>darknet 训练 yolov4-tiny模型</h1><h2 id="为什么是-yolov4-tiny-模型："><a href="#为什么是-yolov4-tiny-模型：" class="headerlink" title="为什么是 yolov4-tiny 模型："></a>为什么是 yolov4-tiny 模型：</h2><p>相比官网教程实例采用的 yolov4 和 yolov3， yolov4-tiny 更加小巧，适合机载电脑使用。</p><span id="more"></span><h2 id="炼丹原料准备："><a href="#炼丹原料准备：" class="headerlink" title="炼丹原料准备："></a>炼丹原料准备：</h2><p>当代的模型训练和神秘东方帝国古老时候的炼丹技术有着高度类似性，所以又被称为“炼丹”，笑。</p><p>首先建议拍摄相应的照片素材（&gt;=500)，要求是尽量体现样本的多样性，这关系到最终模型的准确度，你也不想你的丹药废掉吧。</p><p>然后，你可以参考 <a href="https://github.com/heartexlabs/labelImg">label</a>，配置好标定软件。这里笔者更加推崇 Windows + Anaconda ，其中的 anaconda 是 windows 平台的 python 集成包，对于 python 相关的环境配置有很大的好处（你可以自行百度）。</p><p>关于后续的操作，你可以参考官网的 demo 视频，总之就是四步：1. 选择图片素材的文件夹目录 2. 选择图片标定的类别 3. 在图片上标定方框 4.保存！！！ </p><h2 id="上文火！（三体梗）总之就是开始炼丹了"><a href="#上文火！（三体梗）总之就是开始炼丹了" class="headerlink" title="上文火！（三体梗）总之就是开始炼丹了"></a>上文火！（三体梗）总之就是开始炼丹了</h2><p>你可以查看 github 这个部分 <a href="https://github.com/AlexeyAB/darknet#how-to-train-tiny-yolo-to-detect-your-custom-objects">训练</a> 以及它的上一个部分。<br>大体上是如下几个步骤：</p><ul><li>下载预权重文件，后缀是类似 <code>.conv</code>，可以放在 darknet 主目录</li><li>修改 <code>.cfg</code> 文件，在 darknet/cfg 将其他文件内容修改（这部分需要严格参考官网文档）</li><li>在 darknet/data 内创建 <code>.name</code> <code>.data</code>文件</li><li>在 darknet/data 内创建文件夹，拷入图片素材和对应 txt 文件</li><li>创建 <code>train.txt</code>，内部写入所有图片素材的目录（建议用 excel 或 python 制作）</li></ul><p>最终，进入命令行输入官网上要求的代码，当命令行开始“翻滚”起来时，恭喜，你也是一名炼丹师了。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>本文档写得简略，建议仔细参考官方文档，同时也可以看看  <a href="https://zhuanlan.zhihu.com/p/494058726">比较好的教程</a>（有几处细节与官方不同，记得注意）。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
